# 실용주의 프로그래머

1장. 실용주의 철학

잔디밭을 가꾸듯이
매일 같이 지금 가지고 있는 기술들을 다듬고, 새로운 기술들을 나의 도구 목록에 추가해라.

고양이가 내 소스 코드를 삼켰어요.
와 같은 변명거리를 대기보다는,
인정하고, 적절한 대안과 해결방안을 생각해라
어설픈 변명과 질문을 하기 전에 책상 위의 고양이에게라도 질문해보아라
그 사람이 뭐라고 할 것 같은가? “이런 것은 생각해보셨나요? “...는 해보셨나요?” 와 같은 질문이 떠오른다면
그것에 대한 답을 먼저 찾아야 할 것이다. 다른 사람들의 시간을 뺏지말자

창문이 하나 깨져있는채로 건물이 방치된다면 그 건물은 순식간에 폐가가 될 것이다
깨진창문을 그대로 두지 마라. “아직 구현 안됨”, 주석처리 등 판자를 덮어두기라도 해야한다
매우 아름답게 보존되어 있는 프로그램에는 거센 불길(데드라인, 시사회 데모 등)이 다가와도 사람들은 그 프로그램을 어지럽히는 첫번째 사람이 되고 싶지 않을 것이다

구현할 것이 명확해 보이는 프로젝트가 있다.
이것을 실행하기 위해서는 위원회가 생기고, 예산 승인이 필요하고, 일들이 복잡해진다.
이들을 설득하기는 어렵고, 동의를 구하기도 어렵다.
이럴때는 돌멩이 스프처럼, 일단 저지르고, 만들어 보여주어라.
그리고 다서 “물론 ...같은 것들도 있다면 좋겠지요” 와 같이, 전혀 중요하지 않을 것 처럼 얘기해라

늘 큰 그림에 집중해라. 개구리 스프처럼 주변의 변화에 둔해져서는 안된다.

자신이 하고 있는 일이 돌멩이 스프인지 개구리 스프인지 어떻게 판단할 수 있겠는가?

우리가 생산해낸 것이 어느정도면 괜찮은 것인지를 요구사항으로 만들어야 한다.
완벽한 프로그램을 만들기는 어렵지만, 사람들은 내일 완벽한 프로그램보다, 오늘 그래도 쓸 수 있는 프로그램을 사용할 것이다
우리는 적당한 타협이 필요한 상황에 자주 놓이게 될 것이다.
이것은 그림 그리기와 비슷하여, 과도하게 완벽한 프로그램을 다듬는 것은 어리석다.
어느정도 완성이 되었다면 한동안은 그 상태로 두라

프로그래머가 가지는 기술들은 주식과 비슷한 점이 많다
따라서 우리도 지식 포트폴리오가 필요하다
주기적인 투자
다각화
리스크 관리
싸게 사서 비싸게 팔기
검토 및 재조정

매년 새로운 언어를 하나씩은 배우기    - golang ? swift ?
기술 서적을 분기마다 한 권씩은 읽기    - 이 책이 끝난다면 설계 책을 읽어보자
비 기술 서적도 읽기
수업을 듣기                                    - redhat  수업
지역 사용자 모임에 가기                    - 9xd ? 하이파이브?
다른 환경에서 실험해보기
요즘 흐름을 놓치지 않기                - 뭔가 팔로우하는 매체가 필요할듯
인터넷을 이용하기

최고의 아이디어, 최고의 코드가 있어도 다른 사람과 소통할 수 없다면 궁극적으로 아무 의미가 없다.
개발자로써 우리는 회의를 하고, 듣고 말한다
최종 사용자의 요구를 이해하려고 노력하며, 코드를 작성해서 우리의 의도를 기계에게 전달하고, 사고를 문서화해 다음 세대 개발자들에게 전달한다
제안서와 메모를 작성해서 자원을 요청하고 상태를 보고하고, 새로운 접근법을 제안하고, 팀에서 아이디어를 주장한다
우리는 이를 위해 많은 시간을 할애하고 잘할 필요가 있다

말하고 싶은게 무언지 알아라 (개요를 작성하고, "이것이 잘 전달이 될 것인가?" 자문하라)
청중을 알아라 (최종 사용자, 영업부, 개발자들 각각이 그 프로젝트를 통해 얻고자 하는 것이 다를 것이다)
때를 골라라
스타일을 골라라 (청중들의 스타일에 따라 문서, 요약, 길게 등 다양할 것이다)
멋져 보이게 하라
청중을 참여시켜라 (피드백을 받아라)
청자가 되어라 (귀 기울여라)
응답하라

이메일 역시 마찬가지다.
보내기 버튼을 누르기 전에 맞춤법을 확인하고, 받는 사람을 확인해라

2장. 실용주의 접근법

7. 중복의 해악
DRY - dont repeat Yourself
중복이 생기는 이유
강요된 중복 / 부주의한 중복 / 참을성 없는 중복 / 개발자간의 중복

예를 들면 클라이언트와 서버 간의 공통의 데이터를 표현해야 할때 코드가 중복될 수 있다.
여기서는 ‘코드 생성기’라는 개념을 들어 소프트웨어가 빌드될때마다 간단한 코드 생성기를 사용해 공동의 메타데이터를 만드는 것을 방법으로 제시한다
이런 전처리기를 두고 일하는 것이 현재 회사에서는 어려워 보이고 까다로워 보이기는 하지만
이 문제를 해결하는 한가지 방법이기는 한거 같다.

여기서는 또한 문서와 코드간의 중복을 얘기하고 있는데, 고객이 테스트 명세를 수정할때마다(문서를 수정할때마다) 테스트 슈트가 자동으로 바뀌어 모든 테스트를 통과한다는 것을 보여주는 것을 간소화할 수 있었다고 하는데, 사람들은 참 다양한 방식으로 일하고 있다는 것이 느껴진다.
해당 이야기는 국제 텔렉스 스위치 프로그램에 관한 것인데, 하드웨어와 관련된 상품? 이다보니 고객에게 테스트를 보여줄때의 프로세스를 간소화 했다는 이야기 같다. 근데 사실 이거는 테스트 양식을 만들고 고객이 문서를 바꾸면 그 데이터를 넣어보면 되는 것이니....이렇게 생각해보면 간단하기도 하고 꼭 필요한 과정이겠다는 생각이 든다.

 class Line
Point start
Point end
double length
라고 한다면 start가 바뀔때 length도 바뀌어야 할 것이다. 이것은 DRY원칙에 위배된다.
그렇다고 length를 동적으로 계산되는 속성으로 바꾼다면 성능상의 이유로 DRY원칙을 위배하게 될 수도 있다. (캐싱을 할수도 있을것이다, bool changed 추가)
또한 객체의 속성에 접근하기 위해서는 '일관된 엑세스 함수’를 쓰라고 강조한다. getter,setter를 말하는 거 같은데, 이렇게 해야 속성에 어떤 로직을 추가하기 편할 것이다. (캐싱과 같은)

8. 직교성
관련 없는 것들 간에는 서로 영향이 없도록 해라

팀원들간의 역할에도 직교성을 띄는 것이 좋다고 한다.
어떤 회의가 있다고 모든 팀원들이 관련되어 참석한다면 효율은 그만큼 떨어질꺼라는 얘기다
파트에서 일을 하면서도 이런 생각이 들때가 있었다. 책에서 말한 팀의 규모가 어느정도인지는 모르겠지만
일단 파트의 회의에는 어느정도는 다 같이 들어가는게 도움이 될 때도 있다. (담당자 부재시 대처, 히스토리 파악 등)
이런 것들을 나누는 기준에 대해서도 정해봄직 하다

AOP 로직을 로깅 코드와 엮어서 설명하고 있다. 이역시 코드간의 직교성을 높이는데 도움을 준다
전역 데이터 사용을 주의하라고 한다. 읽기 전용으로 사용하고 있다한들 갑자기 멀티 스레드 환경이 된다면?
일반적으로는 모듈이 필요로하는 context를 넘겨준다고 한다 (android에서 context를 넘기는 경우가 많았던듯..)
특히나 자바와 같이 (아마 c++도 포함될듯) 전역 개념을 허용하지 않는 곳에서 싱글톤 패턴을 많이 남발한다고 하는데
이는 주의하여 사용해야 한다고 한다
(싱글톤의 적절한 사용법에 대해서는 레인스버거의 Use Your Singletone Wisely를 참고
https://www.ibm.com/developerworks/webservices/library/co-single/index.html)

시스템이 직교적이라면 테스트를 하기에도 훨씬 용이하다
통합 테스트보다 테스트 케이스를 만들어야 하는 범위가 줄어들고, 모듈 자신만의 테스트케이스를 만들고 수행하기에 편하고, 이를 빌드과정에 포함시켜야 한다

문서화에서도 내용과 표현이 직교적일 수 있다고 한다. 어느정도는 무슨 말인지 이해가 된다.

도전해볼 것
1. 윈도우 시스템의 전형적인 거대한 사용자 인터페이스 툴 vs 쉘 프롬프트에서 사용가능한 작지만 조합가능한 명령줄 유틸리티. 무엇이 직교적이고 왜 그러한가? 무엇이 해당 툴이 의도한 목적을 정확히 수행하는가? 무엇이 새로운 도전을 맞아 다른 툴과 조합하여 사용하기 편리한가?
    1. 쉘 프롬프트가 더 직교적 - 한 프로그램을 바꾼다고 해서 다른 프로그램에 영향을 끼치지 않는다. pipe를 이용하여 서로간의 결과를 주고 받기 편리하다. 거대한 툴이라면 지원해주지 않는 이상 export해서 형식에 맞추어 import 해주는 과정을 거쳐야 하지 않나?
2. C++은 다중 상속을 지원하고, 자바는 다중 인터페이스를 구현한다. 이것이 직교성에 미치는 영향은? 위임과 상속의 차이점은?
    1. 상속에서는 부모의 코드가 자식에게 영향을 미친다. 인터페이스에서는 명세가 바뀌지 않는 이상 그 구현체들 끼리는 영향을 끼치지 않는다.
    2. 직교적이라는 것은 그 쓰임새에 따라서 각각의 구현체를 알맞게 쓸 수 있다는 것이고 이들간에 영향도는 없다. (단일 스레드일때는 이런 구현체, 멀티 스레드에서는 저런 구현체...이렇게 쓰는 것?)


9. 가역성
최종 결정이란 없다.

A 데이터베이스를 이용하여 프로그램을 개발 중에 어느날 갑자기 B 데이터베이스를 쓰기로 한다. 프로그램은 이 변화를 받아 들 일 수 있는가
만약 데이터 베이스에 대한 아이디어를 올바르게 추상화 해두고 어떤 지점에 영속 서비스 (persistence service, JPA의 그 persistence인듯) 를 제공하도록 했다면 도중에 말을 갈아 탈수 있는 유연함을 갖게 될 것이다.

유연한 아키텍처에 관한 예를 많이 들어주었다.
CORBA와 같은 기술이 개발 언어와 플랫폼의 변경으로 부터 우릴 지켜준다고 한다.
어떤 플랫폼에서 자바의 성능이 나오지 않아 C++로 바꿔도 다른 부분은 바꿀 필요가 없다고 한다
유닉스용이든 윈도우 용이든 대응할 수 있게, 캡슐화를 하고 하드코딩된 로직과 매개변수를 줄이고
마케팅팀이 시스템의 설정파일만 변경하면 독립형, 클라이언트-서버, n-티어 모델 중 하나를 지원할 수 있도록....
이런 것들은 보통 개발 기간에 디펜던시가 높다고 생각한다. 하지만 뛰어난 개발자라면 빠르게 이런 아키텍쳐를 설계할 수 있지 않을까??
아키텍처 뿐만이 아니라 코드 레벨에서도 무언가에 (벤더 프로그램?) 디펜던시가 높은 코드는 좋지 않을 것이다

10. 예광탄
목표물을 찾기 위해 예광탄을 써라

예광탄 개발 방법은 새로운 컴포넌트를 만들때 와꾸를 짜두는 것과 비슷한 것같다.
책에서 든 이방법의 장점은
사용자들은 뭔가 작동되는 것을 일찍부터 보게된다.
개발자들은 들어가서 일할수 있는 구조를 얻는다.
통합 작업을 수행할 기반이 생긴다.
보여줄 것이 생긴다.
진전 상황에 대해 더 정확하게 감을 잡을 수 있다.

예광탄 방법과 대비되는 거대 공학적 접근 방식
각 모듈은 진공상태에서 개발해 하위 시스템을 만들고 다 만들어졌을때 비로소 하나로 합쳐 작동되는 것을 볼 수있다.
프로토타입 제작과 다른 점 
프로토타입이란 만들고자 하는 제품의 어떤 특정 단면을 빠르게 보고 싶은 것이다.
사용자에게 필요한 GUI 배치라든지..쉬운 언어로 빠르게 만들고 보여준뒤, 실제로 만들때는 그것을 버리고 실제 개발 언어로 개발 할 것이다.

현재 팀내에서 앵귤러로 view를 만들고자하는 시도가 이 예광탄 코드를 필요로 할 것같다

11. 프로토 타입과 포스트 잇
프로토 타입을 통해 학습하라

다양한 분야에서 프로토타입을 사용한다.
자동차, 항공 분야에서는 공기역학, 스타일, 구조적 특성 등을 테스트하기 위해서 프로토타입을 설계하고, 풍등시험을 위해 점토 모델을 만들고, 디자인 부서라면 나무와 테이프로 만들 것이다.

반드시 코드로 작성해야 하는 것은 아니다. 포스트잇이나 화이트보드도 충분한 도구가 된다.



