# 암호화 기본 지식

정의
허가된 이 외에는 읽을 수 없도록 정보를 부호화 한 것
부호화하는 방식을 암호화 알고리즘이라고 한다

구분
키의 갯수
* 비밀키 (대칭키)
* 공개키 (비대칭키)
데이터의 처리단위
* 스트림
* 블록
원본 복호화 여부
* 단방향
* 양방향

해쉬함수
* 임의의 길이의 입력을 고정된 길이의 출력으로 바꾸는 함수
* 동일 입력에 대해 동일 출력을 보장
* 출력값은 digest 라고 한다

암호화 해쉬
일반 해쉬 함수에 다음 3가지 특성을 만족하는 것
복호화가 안되므로 단방향에 속한다
1. 역상 저항성
    * 주어진 해쉬 값에 대해 그 해쉬 값을 생성하는 입력 값(M)을 찾는 것이 계산 상 불가능
        * rainbow attack
            * 역상 저항성을 우회해서 입력값을 찾기 위한 brote-force attack의 일종
            * rainbow table을 작성해서 획득한 해쉬값을 이와 비교
            * 입력 값에 임의의 값(salt)를 추가해서 hash를 계산하면 방지 가능
2. second 역상 저항성
    * 주어진 입력 값(M)에 대해, 동일한 해쉬값을 갖는 입력값(M`)을 찾는 것이 계산상 불가
3. 충돌 저항성
    * 같은 해쉬값을 생성하는 두개의 입력값(M1,M2)을 찾는 것이 계산상 불가능

용도
* 메시지의 무결성 확인에 주로 사용
* 원본 파일의 checksum
* 메시지 위변조 검출 및 인증
* 전자 서명 시 속도향상을 위해 원본에 hash 함수를 적용한 digest 값에 서명 (원본이 hash함수의 출력값보다 클테니)

Merkle Tree (Hash tree)
* 대량의 데이터를 빠르게 검증하고 손상된 데이터를 찾아낼 수 있는 자료구조
* git의 내부 저장소 (commit hash ?), bitcoin의 blockcahin에 사용

해쉬 알고리즘의 종류
* MD5, SHA1, SHA2(SHA256, SHA384, SHA512)

대칭키 알고리즘
* 하나의 키를 사용
* 암/복호화 속도가 빠르다
* 블록, 스트림 암호 알고리즘으로 구분
    * 스트림 암호 알고리즘
        * 대칭키를 만든 후에 bit 단위로 XOR 수행. 속도는 빠르지만 실무에서는 거의 쓰지 않음
    * 블록 암호 알고리즘
        * 데이터를 블록 단위로 암/복호화
        * DES, AES(미국 표준, 128, 192, 256 bit), SEED(국내 표준, 128bit)
        * padding
            * 입력 데이터가 블록 사이즈의 배수가 아니라면 PKCS7 padding (부족한 size만큼 바이트 값을 추가)
                * 3byte 부족 - 03을 3개. 4byte 부족 - 04를 4개
        * 운영 모드 (operation mode) 운영모드가 정확히 뭐야 ..?
            * 입력 데이터가 블록보다 크므로 발생하는 여러 블록들간의 관계를 처리
            * ECB electronic code book
                * 개별 블록을 각각 암복호화 수행 (운영모드 없음)
                * 입력값을 유추 가능. 치명적인 문제
                * 대칭키 암호화시에는 사용하면 안됨
            * CBC cipher block chaining
                * 직전 블록을 다음 블록의 입력으로 사용
                * 초기 블록은 직전 블록이 없으므로 key 이외에 initial vector 사용
                * <이미지 삽입>
                * 단점
                    * 이전 블록 결과가 다음 블록의 입력이라 병렬 처리 불가능
                        * 멀티 프로세서의 장점 못살림
                    * 용량이 클수록 시간이 오래 걸림
                    * 특정 블록만 복호화 불가
                    * padding 필수
                    * 메시지 인증 (MAC)에 사용불가
            * GCM galois/counter mode
                * CBC의 단점 해결
                * 패딩 불필요
                * 인증 기능 제공
                * 병렬처리 가능
                * 브라우저와 서버 지원시 SSL/TLS에서 많이 사용
                * 아직 활성화 X
            * <이미지 삽입, ECB, CBC 비교>
            * <이미지 삽입, 코드>
            * key, IV
                * 대칭키와 IV는 랜덤값을 주로 사용
                * 암복호화시 이를 입력해야 되지만 랜덤값이라 사람이 기억하기는 무리가 있음
                * PBKDF2 password-based key derivation function 2
                    * 사람이 기억할 수 있도록 암호를 기반으로 random key 생성
                    * password + salt -> n번 hash 수행
                        * key stretching
                            *  broute-force attack 을 방지하기 위해 충분히 iteration을 수행
                    * 암복호화시 사용자에게 암호를 입력받는 SW는 대부분이 이 방법
                    * 이거 복호화는 어떻게 하는거지?
* 단점
    * 상대방과 key를 공유해나 안전하게 전달이 어려움
    * 통신 상대방이 많아질수록 키 관리가 어려움
        * n(n-1)/2 개의 키 필요

공개키 알고리즘
* 하나의 키(public key)는 공개, 하나의 키는 안전하게 보관(private key)
* private key로 암호화한 것은 public key로만 복호화 가능
* 대칭키의 단점인 암호 통신시 key공유 문제를 해결
* <사진>
* 종류
    * RSA - 인수분해의 어려움을 기반으로 한 알고리즘
    * Rabin - RSA와 유사
    * DSA - 이산대수의 어려움을 기반 - 전자서명 기능만 제공
    * ECDSA - 속도가 빠른 타원 곡선 (bitcoin에서 사용)
* 개인키 암호화
    * 개인키로 암호화한 내용은 공개키로만 검증 가능한 원리를 이용
    * 개인키 소유자가 만든 데이터를 알 수 있으므로 송신자를 식별할 수 있다
    * 송신자의 메시지 작성 사실을 부인하지 못하므로, 부인 방지(non-repudiation)이라고도 함
    * 개인키 암호화를 전자서명이라고 한다
    * <사진>
* 공개키 암호화
    * 수신자의 공개키로 데이터 암호화
    * 해당 데이터는 개인키를 가지고 있는 수신자만이 해독할 수 있으므로 안전하게 데이터 전달이 가능
    * <사진>
* <결과물 사진>
* 단점
    * 복잡한 수학적 연산때문에 구현이 매우 어려움
    * 대칭키에 비해 몇 백배 이상 느림

키 교환
도/감청이 가능한 채널에서 암호화 통신을 하기 위해서는 안전하게 key를 교환할 방법이 필요하다
키 동의 / 키 암호화 방법이 있다
* 키 동의 (key agreement)
    * 통신 당사자들이 사전에 준비한 공개키 쌍이 없이도 정해진 알고리즘에 의해 안전하게 키를 합의, 동의
    * 디피-헬만 알고리즘이 유명
        * 이산대수의 어려움에 기반
        * 암호화되지 않은 통신망에서도 상대방의 공개키 없이도 안전하게 secret key 공유 가능
        * SSL, SSH 등 암호화 통신에 많이 사용
        * <추가 설명 필요>
* 키 암호화
    * 수신자가 대칭키 생성 후 상대방의 공개키로 암호화하여 전달
    * 상대방은 자신의 비밀키로 복호화하여 대칭키를 획득
    * 이후는 서로 대칭키로 데이터를 주고 받음
* 암호화 통신
    * SSH, SSL 등 암호화 통신은 속도 때문에 대칭키 방식을 사용
    * 대칭키 교환은 키 동의나 키 암호화를 통하여 안전하게 공유
    * 2가지 방식을 혼용하여 대칭키 방식의 단점 (키 공유), 공개키 방식의 단점 (속도) 을 해결
    * 사용하는 대칭키는 암호화 통신 세션 내에서만 유효하므로 sesstion key 라고 함
    * SSL 성능을 높이려면 초기 키 교환의 부담을 줄이기 위해 session key cache 기능이 필수 (timeout 시간은 적절히)
* 역사
    * 미국는 40비트 이상의 key 길이를 사용하는 암호화 기술을 전략물자로 취급, 무기 수출통제법 대상으로 삼음
    * PGP(prettry good privacy) 필 짐머만이 개발한 SW
        * 이것의 등장으로 개인도 전자서명, email 암호화가 가능
        * 미국 정부는 PGP SW의 수출을 무기 수출 통제법으로 금지
        * 필 짐머만은 SW는 대상이지만 책은 아닌 것에 착안, 책으로 출판하여 수출
* 공개키 획득
    * 인터넷과 PGP의 등장으로 개인도 암호화된 이메일을 주고받는게 가능해짐
    * -> 이를 위해서는 당연히 상대방의 PGP 공개키가 필요
    * -> 공개키 저장소가 필요해짐
    * -> 공개키 저장소에 등록된 공개키가 그 상대방이 맞는지 확인할 방법이 필요해짐
    * -> 인증 기관이 필요해짐. CA (certificate authority)
* 인증 기관
    * 공개키의 소유자를 인증 (Certification) 해줌
    * 상대방의 공개키는 CA의 개인키로 전자 서명
    * 이 데이터를 공개키 인증서 (public key certificate) 이라 한다
    * 암호화 통신시 상대방의 공개키 인증서를 CA의 공개키로 복호화하여 위/변조 여부를 확인
    * 이 공개키 인증서는 CA가 인증하였으므로 신뢰
    * 웹 사이트의 경우 SSL 인증서 신청자가 도메인의 소유자가 맞는지 소유권을 검증
        * 그렇다면..브라우저가 특정 도메인에 접근 시 HTTPS 통신을 위해 SSL 인증서를 받아가면
        * SSL 인증서를 CA의 공개키로 복호화 하겠지?
        * 복호화해서 나온 데이터는 무엇일까 ?? -> 서버가 브라우저로 전달하고 싶었던 정보 or 대칭키 ??
    * 중국의 몇몇 CA는 소유권 검증을 허술하게 하여 firefox, chrome으로부터 퇴출 당했다 (신뢰할 수 없는 CA)
    * CA 인증서 체인
        * 브라우저에는 신뢰하는 여러 CA 인증서가 사전 등록됨
        * 
        * 계층 구조이므로 체인이라고 표현
* 인증이란?
    * 인증 : Authentication, Certification
    * Authentication
        * 어떤 이가 실제하고 그가 맞는지 확인하는 것
        * 온라인 상에서 신원을 확인하는 것
        * 지식기반 : password, 이미지 선택, 패턴 매칭
        * 소지기반 : 보안카드, OTP, 스마트카드
        * 생체기반 : 지문, 홍채, 정맥, 얼굴, 목소리 등
    * Certification
        * 특정 행위를 할 자격을 갖췄다는 뜻
        * 의사 자격증, 졸업 증명서, 운전 면허증 등
        * 흔히 이야기하는 공인 인증서는 사용자 공개키를 인증 기관이 Certification 했다는 뜻
        * 공인 인증서는 인증 (Auth)보다는 전자 도장의 용도. 부인 방지를 제공
* key 관리
    * A 서비스의 보안 수준
        * 비밀번호는 SHA-256과 salt로 hash하여 보관중
        * 개인정보는 AES256-CBC 모드를 사용하여 암호화
        * 방화벽과 침임 탐지 시스템 운영중
    * 하지만 데이터(DB)와 key가 유출된다면?
        * key는 digital data이므로 무한 복제가 가능..
    * HSM : hardware security module
        * key 관리문제를 해결해주는 전용 하드웨어
        * 장비 내에서 key 생성하고 내부에서 암호화 연산 수행
        * 장비 내의 key는 외부로 유출 불가 (FIPS140-2)
        * 보안 레벨이 높은 제품은 임의 분해시 key 파괴 기능 내장
        * 고가이며, 사용하기 위해선 별도의 프로그래밍이 필요
        * AWS - key management service (KMS)
        * Azure - key vault service
        * Cloud 환경에서 중요한 정보를 암호화하려면 HSM Managed Service 권장
* 사례별 암호화 적용 방법
    * 암호화는 시스템과 데이터가 털리는 최악의 상황에 대비한 최후의 보루
    * 기본적으로 보안 취약점 패치/ 업데이트, 방화벽, SELinux, 침입탐지, Secure coding 등의 보안 대책을 선적용해야 한다
    * 단방향 암호화 ( 사용자 암호 )
        * 
