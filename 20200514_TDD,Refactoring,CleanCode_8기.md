# TDD, Refactoring, Clean Code 8기 수업

* full time online 수업 진행
  * 2020-05-09 ~. 020-07-04
* with javajigi 박재성님



## 0강 시작하며

#### 심리적 안정감이란?

회사 혹은 교육에서 어떠한 의견을 제시해도 불이익을 받거나, 팀원간에 불만에 생기지 않을거라고 믿는 조직, 교육 환경

심리적 안정감이 있어야 업무, 교육이 모입할 수 있고 자유로운 의견 교환이 가능해 최고의 효율을 낼 수 있다.



## 자동차 경주 게임 피드백

* 네이밍(이름 짓기)
  * 객체지향 생활 체조 규칙 5: 줄여쓰지 않는다.
  * (효과적인 이름짓기)[https://remotty.github.io/blog/2014/03/01/hyogwajeogin-ireumjisgi/]
    * 변수 이름의 길이는 평균 10~16
    * 계산된 값을 보관하는 변수 (Total, Sub, Average, Max, Min, String ....)
      * 이름의 끝에 붙이는게 좋다
      * Num 의 경우 예외, Counst, Index 로 바꿔서 쓰는게 좋다
* final
  * 요즘 언어들은 final 변수를 지원한다. var / val
    * java 11 부터도 지원된다
  * 조금이라도 버그 가능성을 낮추고 안정적인 코드를 만들기 위해서는 immutable object 를 만드는게 중요하다
* 핵심 비즈니스 로직에서 getter, setter 를 쓰지 마라
  * DTO 에서는 써도 된다
* 테스트 가능한 코드와 테스트하기 힘든 부분을 분리
  * 랜덤값을 Car 클래스 내부에서 생성하면 테스트하기 힘들다.
  * 이럴때는 분리, 인터페이스로 추출하면 테스트 가능해진다
  * [DateMessageProvider에 대한 정리 및 느낀 점](https://www.slipp.net/wiki/pages/viewpage.action?pageId=6160426)
* getter. setter
  * 상태 데이터를 get하지 말고 메시지를 보내라
    * 객체의 데이터를 꺼내 로직을 구현하면 중복 코드가 발생한다
    * 객체에 메시지를 보내 상태 데이터를 가지는 객체가 일하도록 하라
  * 객체지향 생활 체조의 모든 원칙은 `핵심 비즈니즈 로직`을 위한 것이다



## 2강 로또 - TDD

* 회사가 요구하는 역량은?
  * 다른 사람이 읽기 좋은 클린코드
  * 다른 사람들과 원할히 소통하고, 팀워크를 만들어갈 수 있는 협업 능력
  * 자기 주도적으로 문제를 해결하는 능력
* 정적 팩토리 메서드
  * 생성자가 2개 이상이 되면 생성자로 의도를 드러내기 힘들다
    * 어떤 생성자를 사용해야 하는지 늘 document를 봐야 한다
* TDD란?
  * TFD + 리팩토링
  * 프로덕션 코드를 추가할 때 마다 리팩토링이 이뤄줘야 한다. 한번에 몰아서 하겠다는 것이 아니다
  * 반드시 실패하는 테스트 코드가 있어야만 프로덕션 코드를 수정할 수 있다
* 과제 수행
  * 구현할 기능 목록 작성하기
  * 로또 기능 구현할 때는 일단 구현을 먼저 해보고, 테스트해볼 수 있는 가장 작은 단위 (의존성이 없는 노드, 유틸성 메소드를)를 TDD로 구현한다
  * 구현할 기능 목록을 먼저 작성하고, 커밋
  * 특정 기능을 골라서, 실패하는 테스트를 작성한다 커밋
  * 프로덕션 코드를 작성한다. 커밋
  * 리팩토링 진행. 커밋
  * 리팩토링 하면서 테스트해야할 메소드, 클래스가 추가로 생긴다면 테스트를 추가. 커밋
  * 지켜야할 요구사항을 다 지키고 있는지 확인
  * 다음 기능을 구현....







현재 이 클래스는 상태를 가지고 있지 않고, 행위만 가지고 있네요. 그렇다면 유틸리티 클래스인지, 객체인지 명확하게 하는 편이 좋을 것 같습니다.

다만 모든 생성자와 정적 팩토리 메소드는 주 생성자를 리턴하고, 검증 코드는 주 생성자에서만 이루어지게 하면, 검증코드 반복도 줄일 수 있다는 점을 기억해주세요:)



## 3강 사다리타기 - FP, OOP

### 클린코드와 구현 역량이 중요한 이유는?

어제의 자기 자신과 경쟁한다

코드를 자동화하려면 요구사항을 애매하게 주어도 사람의 의도를 정확히 꿰뚫어 프로그램을 완벽하게 실행할 수 있어야 한다.

코드는 항상 존재할 수 밖에 없다. 따라서 우리는 코드를 깔끔하게 구현하는 것에 관심을 가져야 한다.

동작하는 코드를 만든 뒤에는 관심이 없어진다.

"나중은 결코 오지 않는다." - 르블랑의 법칙

클린코드를 한다고 해서 생산성이 높아지지 않는다. 생선성을 일관되게 유지하기 위해서다.

### 함수형 프로그래밍

가장 작은 단위의 모듈화는 객체가 아니라 함수이다.

기존에 객체지향적으로 접근했던 설계, 개발 방식에 대해 새로운 시각을 배울 수 있다.

TDD를 하다보면 문제를 작은 단위로 쪼개는 방법에 대한 연습이 필요한데, 함수형 프로그래밍을 하다보면 이 능력이 발달할 수 있다.

함수형 프로그래밍은 선언형 프로그래밍의 일종 (하스켈, SQL, HTML, XML 등)

* 함수형 언어의 특징
  * immutable value를 활용
    * 값이 변경되는 것을 허용하면 멀티 스레드 프로그래밍이 힘들다.
    * 값을 변경할 수 없는 경우 프로그램의 정확성을 높여 버그 발생 가능성을 줄인다.
  * 함수가 1급 객체(first class citizen)
    * 변수나 데이터에 할당 할 수 있어야 한다.
    * 객체의 인자로 넘길 수 있어야 한다.
    * 격체의 리턴값으로 리턴할 수 있어야 한다.
  * 람다는 익명 함수의 다른 표현
  * 고계 함수. 다른 함수를 인자로 받아 함수를 리턴하는 함수. 함수형 프로그래밍은 함수가 1급객체이 될 수 있기에 가능

FP를 제대로 연습하고 싶다면 FP를 지향하는 언어로 연습하는 것이 좋다.

* 자바 개발자로서 FP를 대하는 자세
  * 프로그래밍의 기본 틀은 OOP 기반 (클래스 기반)
  * 메소드 내부 구현은 FP를 지향
  * 객체의 상태 관리는 immutable object 지향

### 책임주도설계

* Bottom Up 구현 및 설계

  * 전체적인 도메인 지식이 부족하여 일단 클래스 메소드를 구현하고, 지속적인 리팩토링
  * 객체 지향 생활 체조 원칙에 근거하여 리팩토링
    * 일단 구현하고, 상수 추출, 메소드 추출, 일급컬렉션으로 추출, 테스트하기 쉬운 구조로 리팩토링 등

* Top Down 설계 및 구현

  * 책임이란 무엇인가?
    * 책임이란 객체에 의해 정의되는 응집도 있는 행위의 집합
    * 객체가 **무엇을 알고 있는가? 무엇을 할 수 있는가?** 로 구성된다
  * 요구사항 분석 후 책임을 먼저 찾고, 책임을 담당하는 클래스를 설계한다

* 책임 주도 설계 과정

  1. 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.

  2. 시스템 책임을 더 작은 책임으로 분할한다.

  3. 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.

  4. 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
  5. 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

협력이라는 문맥 안에서 역할은 특정한 협력에 참여해서 책임을 수행하는 객체의 일부다.

일반적으로 역할은 객체가 협력에 참여하는 잠시 동안에만 존재하는 일시적인 개념 이다





책임주도설계(Top-down) 방식으로 개발을 할때 클래스 다이어그램이나 데이터베이스 스키마 다이어그램 등을 그려보면 좀 도움이 될 것 같은데 이런 ERD를 만들면서 개발하는 것에 대해서는 어떻게 생각하시나요?
그리고 전 지금 회사가 첫 회사이고, 여기는 다이어그램까지 그려가면서 설계를 하진 않습니다. 다른 회사들은 어떤지 궁금합니다 !


클래스를 어떻게 나눠야 할지 모르겠다 싶으면 static 메소드로 일단 구현해봐라
메소드의 파라미터들은 일급컬렉션, 클래스로 분리되어야 하는 신호이다

primative type 이라도 LottoNumber 처럼 클래스로 만들 수 있다.
근데 primative 변수를 쓰는데 굳이 LottoNumber 인스턴스를 만들면 성능상 이슈가 있을 수 있다는 챌린지를 받을 수 있다
이때는 돌아가는게 아니라 고민을 해봐야 한다.
1 ~ 45까지의 숫자를 미리 캐싱해두고 사용한다면 성능 이슈를 줄일 수 있다
flyweight 패턴이라고 한다

다이어그램은 2000년대초에 유행했던 기법
이때는 설계하는 사람과 개발하는 사람을 나눠서도 프로젝트를 진행할 수 있다고 생각했음
하지만 사람이 신이 아닌 이상 처음부터 다 설계할순 없었기에 대부분 실패

요즘은 JPA를 많이 써는데, 이때는 클래스 다이어그램을 먼저 그려보고

도메인 객체에 대한 클래스 다이어그램 정도는 그려보고 시작하는 편
공유하는데는 클래스 다이어그램이나 ERD는 좋은 수단이다
하지만 시간이 지나면서 많이 바뀌기 때문에 시간을 너무 투자하는 것은 좋지않다.
어느정도 성숙했을때 정리해서 기록해두는 것이 더 의미 있을 것이다.

exception 을 throw 할때 exception 의 성격이 무엇이냐를 규정해보는게 중요하다
도메인의 예외사항이여서 이걸 사용자에게 알려줘야되, 에러메시지를 사용자에게 보여줘야되. 라고 한다면 Controller 에서 try-catch 해야 한다고 생각한다.

결제 금액이 부족하다면 도메인 영역에서 예외가 발생하고, controller에서 try-catch 하고 사용자에게 알려주는게 좋겠고,
로그인을 하지 않은 사용자를 로그인

도메인 로직에 대해서는 checked exception을 하고, 이외에는 runtime exception으로 구현해라
하지만 checked exception을 남발하진 마라

exception이 비싼 비용이 맞다. 하지만 exception은 에러코드를 반환하는것보다 진보된 결과
에러코드를 반환하는 것은 유지보수가 상당히 힘들다
하지만 exception 당 에러코드, 메시지가 정의되고 그것을 반환하는 것은 좋다고 생각



각 도메인 영역을 나눠보고, 그걸 기준으로 MSA의 부분들을 만들어볼 수 있다



린치핀
앞으로 어떻게 살아야하나가 고민된다면 읽어볼만한 책
그래도 내가 전문가라면, 클린코드를 추구하고 소프트웨어 장인이 되기위해 노력해야 하는 것





과제 진행하면서 끄적였던것

사다리타기


세로줄 Line
false true false true
true true 연결될 수 없다
0번 위치는 +1
1번 위치는 -1
2번 위치는 +1
3번 위치는 -1

최소 1칸 이상 생성해야함


세로줄 여러개 Ladder
false true false true
false false true false
false true false false
false true false true

0번 결과는 0
1번 결과는 3
2번 결과는 2
3번 결과는 1

최소 1줄 이상 생성해야함


Ladder 생성해주는 LadderCreator
Ladder 를 생성하는 것은 Ladder 자신이어야 한다
Line 을 생성하는 것은 Line 자신이어야 한다
LineCreateStrategy

new Ladder(height, width, RandomLineCreateStrategy)



Controller LadderGame


유저, 유저들


상품, 상품들
'꽝' 혹은 숫자가 들어와야 한다



유저 + 상품 : 결과 클래스
이름을 넣으면 결과가 나옴
all을 넣으면 전체 결과가 나옴

유저와 상품의 수가 같아야 한다





Player 하위에 Frames 를 빼기

Frames -> BowlingLane

재귀없애기
변수 이동
메소드 이름 변경
ResultType 코드 개선
List<Integer> -> Score 클래스
Frame 하위에 Pin 클래스
메소드 분리, 이름 변경

Frame 추상 클래스를 상속받도록 구현



BowlingGame

Frame


Pin
Score


Player
이름 검증

Frame extend LinkedList
int frameNo
State state
Score score

state bowling(pin)
List<Shot> calculateShotHistory(frameNo)

Score
지금 Frame에서 Pin을 굴릴수 있는지 (10개가 넘진 않는지)
남은게 몇개인지 확인

Pin
11넘지 않도록 값 검증

State
boolean isFinish()

Shot
of(boolean isFirst, int pin, int remain)
    

Frame
bowling(pin)

state.isFinish && finalFrame 이다 -> 예외 발생

state.isFinish -> 새로운 Frame 시작이다
새로운 Frame 생성해서 LinkedList에 추가
frameNo를 올리고
스코어 올린다

-> 이전 Frame의 스페어 처리
스코어 올린다


-> 보너스 Frame이다
스코어를 초기화
스코어 올린다



state = score.add(pin) -> 현재 pin 을 굴릴 수 있는지 유효성 검증하고 더한다


Frame























